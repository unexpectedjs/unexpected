/*global expect*/
describe('exportType', () => {
  var parentExpect;
  var childExpect;
  beforeEach(() => {
    parentExpect = expect.clone();
    childExpect = parentExpect.child();
  });

  it('is chainable', () => {
    childExpect
      .exportType({ name: 'abc', identify: false })
      .exportType({ name: 'def', identify: false });

    expect(parentExpect.getType('abc'), 'to satisfy', { name: 'abc' });
    expect(parentExpect.getType('def'), 'to satisfy', { name: 'def' });
  });

  it('makes the type available to the parent expect', () => {
    childExpect.exportType({
      name: 'fooString',
      identify(obj) {
        return typeof obj === 'string' && /^foo/.test(obj);
      }
    });

    parentExpect.addAssertion('<fooString> to foo', (expect, subject) => {
      expect(subject, 'to equal', 'foo');
    });
  });

  it('does not make the type available to a parent parent expect', () => {
    childExpect.child().exportType({
      name: 'abc',
      identify(obj) {
        return obj === 'abc';
      }
    });
    expect(parentExpect.findTypeOf('abc'), 'to satisfy', { name: 'string' });
  });

  it('binds the type to the child expect so custom types are available to the inspect function', () => {
    childExpect.addStyle('fancyQuotes', function(text) {
      this.text('>>')
        .text(text)
        .text('<<');
    });

    childExpect.exportType({
      name: 'yadda',
      identify(obj) {
        return /^yadda/.test(obj);
      },
      inspect(value, depth, output, inspect) {
        return output.fancyQuotes(value);
      }
    });
    expect(
      parentExpect
        .createOutput('text')
        .appendInspected('yaddablah')
        .toString(),
      'to equal',
      '>>yaddablah<<'
    );
  });

  it('binds the type to the child expect so custom types are available to the diff function', () => {
    childExpect.addStyle('fancyQuotes', function(text) {
      this.text('>>')
        .text(text)
        .text('<<');
    });

    childExpect.exportType({
      name: 'yadda',
      identify(obj) {
        return /^yadda/.test(obj);
      },
      inspect(value, depth, output, inspect) {
        return output.fancyQuotes(value);
      },
      diff(actual, expected, output) {
        output
          .text('got ')
          .fancyQuotes(actual)
          .text(' but expected ')
          .fancyQuotes(expected);
      }
    });
    expect(
      parentExpect
        .getType('yadda')
        .diff(
          'yaddafoo',
          'yaddabar',
          parentExpect.createOutput('text').text('hey, ')
        )
        .toString(),
      'to equal',
      'hey, got >>yaddafoo<< but expected >>yaddabar<<'
    );
  });

  it('should correctly append output generated by a inspect function that does not return the output', () => {
    childExpect.addStyle('fancyQuotes', function(text) {
      this.text('>>')
        .text(text)
        .text('<<');
    });

    childExpect.exportType({
      name: 'yadda',
      identify(obj) {
        return /^yadda/.test(obj);
      },
      inspect(value, depth, output, inspect) {
        output.fancyQuotes(value);
        if (value.length > 5) {
          output.append(value.substr(0, value.length - 1));
          output.appendInspected(value.substr(0, value.length - 1));
        }
      }
    });
    expect(
      parentExpect
        .createOutput()
        .appendInspected('yaddafoo')
        .toString(),
      'to equal',
      '>>yaddafoo<<yaddafo>>yaddafo<<yaddaf>>yaddaf<<yadda>>yadda<<'
    );
  });

  // Weird regression test, used throw TypeError: Cannot read property 'subject' of undefined
  it('should not break when inspecting the exported type in a diff', () => {
    childExpect.exportType({
      name: 'abc',
      identify(obj) {
        return obj === 'abc';
      }
    });
    expect(
      () => {
        expect(parentExpect.findTypeOf('abc'), 'to satisfy', {
          name: 'string'
        });
      },
      'to throw',
      /^expected/
    );
  });
});
